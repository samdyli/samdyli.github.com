---
title: 深入理解java垃圾回收
---



# {{page.title}}

------

## 一、GC概述

Java与C++在内存管理上最大的一个区别：C++需要在程序中实现内存分配和回收过程，稍有不慎就会产生内存泄露问题，Java虚拟机通过垃圾回收机制管理内存回收。



垃圾回收算法关注解决如下问题：

（1） 对象已死怎么判定： 哪些对象可以被判断为垃圾，需要被回收？

（2） 垃圾回收算法：使用什么方法回收不用内存？

（3）具体垃圾收集器及其应用： HotSpot支持哪些垃圾回收器，这些垃圾回收器使用的场景。

具体介绍垃圾回收算法之前，先介绍下JVM的内存模型。

## 二、JVM内存模型

![内存模型](/blog/images/内存模型.png)


上图是jvm的内存模型。从两个维度看jvm内存模型：（1） 各个区域存放什么东西？ （2）区域是否线程私有？

| 区域                          | 存放东西                                                     | 线程私有 | 可能异常           |
| ----------------------------- | ------------------------------------------------------------ | -------- | ------------------ |
| 执行计数器                    | 存放当前线程正在执行字节码的行号                             | 是       | 唯一无异常的区域   |
| 堆                            | 垃圾回收器管理的主要内存区域，存放运行中的对象               | 否       | OOM                |
| 虚拟机栈                      | 有方法执行过程，都会建立一个栈帧。栈帧存放局部变量表、操作数栈，动态链接和方法出口信息。局部变量表存放入参（基本类型和引用类型），编译期间分配完成。 | 是       | StackOverFlow和OOM |
| 本地方法栈                    | 同虚拟机栈，区别是执行的是本地方法（）                       | 是       | StackOverFlow和OOM |
| 方法区（非堆内存， “永久代”） | 已经加载的类的信息、常量（final修饰）、静态变量（static）、即时编译后的代码。 | 否       | OOM                |



说明几点问题：

（1） 方法区不完全等同于永久代。 永久代只是具体JVM实现，将堆得垃圾回收机制运用到方法区。有的JVM并不会对方法区进行垃圾回收，所以也不会有永久代的概念。

（2）运行期间常量池是否存放在方法区中，跟Jdk版本有关。Jdk1.6及之前，常量池存放在方法区中，方法区会因为常量池导致OOM。Jdk1.7和之后版本，常量池从方法区移到了Java堆中。

（3） 直接内存（Direct Memory）又称为堆外内存，它不会被JVM垃圾回收器回收，也不需要在工作内存（Java堆）和本地内存之间赋值，因此性能比较高。

## 三、对象已死

对象被回收之前，需要判断对象是不是已经“死亡”。常用判断对象“死亡”方式有两种**引用计数和可达性分析**。

### 3.1 引用计数

每个对象添加一个引用计数的属性。对象被引用时，这个数值加1。引用被释放时，数值减1。通过对象的引用计数是否为0，判断对象实例的“生死”。

成熟的JVM垃圾回收器很少用这种方法。原因是这种方式存在**循环引用**的问题。

A对象持有B对象，同时B对象持有A对象。没有任何对象持有A和B，A和B对象都已经“死亡”，但是会被引用计数的方式判断为“存活”。

### 3.2 可达性分析

主流垃圾回收器都是使用**可达性分析**判断对象是否“存活”。算法大致过程是分析起点是**GC Root**， 所有存活的对象都可以通过**GC Root**引用链访问到。栈、方法区、本地方法区等区域不能被垃圾回收器回收，因此可以作为**GC Root**。

（1） 虚拟机栈（栈帧中的本地变量表）中引用的对象

（2） 方法区静态属性引用的对象

（3） 方法区常量属性应用的对象

（4） 本地方法区中通过JNI（Native方法）引用的对象

### 3.3 引用

jdk1.2之后，jvm定义了4种引用，分别为**强引用、软引用、弱引用、虚引用**。

| 引用类型                    | 被回收时机                               |
| --------------------------- | ---------------------------------------- |
| 强引用（Strong Reference）  | 无论如何不会被回收                       |
| 软引用 （Soft Reference）   | 内存不足时被回收                         |
| 弱引用（Weak Reference)     | 下一次Gc时被回收                         |
| 虚引用（Phantom Reference） | 不影响对象的生存周期，被Gc时收到系统通知 |

## 四、回收算法

常见垃圾回收算法包括**复制、标记-清除、标记-整理**。

| 回收算法  | 适用于 | 优点                         | 缺点                         |
| --------- | ------ | ---------------------------- | ---------------------------- |
| 标记清扫  | 老年代 | --                           | 效率低、内存碎片问题         |
| 复制      | 年轻代 | 没有内存碎片的问题，简单高效 | 浪费一半的空间，需要分配担保 |
| 标记-整理 | 老年代 | --                           | --                           |



垃圾回收算法过程如下图所示。

![垃圾回收算法](/blog/images/垃圾回收算法.png)

## 五、 HotSpot垃圾回收器

目前HotSpot提供**7种** 垃圾回收器。按照**回收区域（年轻代、老年代）、垃圾回收算法、串行/并行、新/老框架、目标**对垃圾回收器进行分类如下：

（1） 回收区域

- 年轻代：Serial, ParNew, Parallel Scanvenge
- 老年代 : SerialOld， Parallel Old，  CMS
- 年轻代和老年代：G1

(2) 垃圾回收算法

- 复制：Serial, ParNew, Parallel Scanvenge
- 标记清除: CMS
- 标记整理：SerialOld， Parallel Old

> G1 整体上看使用标记-整理算法，局部看属于复制算法。

（3）串行/并行

- 串行： Serial、SerialOld
- 并行：其他5种

（4）框架

- 新框架： G1、Parallel Scanvenge
- 老框架： 其他5种

（5） 目标

- 最小停顿时间：除了Parallel Scanvenge之外的其他6种
- 最大吞吐量：Parallel Scanvenge

7种垃圾回收器详细对比如下表所示。

| 垃圾回收器         | 新生代/老年代 | 并行/串行 | 垃圾回收算法                    | 使用场景                                                     | 优缺点                                                       |
| ------------------ | ------------- | --------- | ------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Serial             | 新生代        | 串行      | 复制                            | client模式时默默认新生代垃圾回收（分配内存小、）             | 优点：简单、没有线程切换，单核情况下效率<br />缺点：大内存条件下，回收效率低 |
| Serial Old         | 老年代        | 串行      | 标记-整理                       | client模式下使用<br />或者server模式使用场景如下：<br />1. jdk1.5及其之前和Parallel Scanvenge搭配<br />2. 作为CMS后备（Concurrent Model Failure）方案 |                                                              |
| ParaNew            | 新生代        | 并行      | 复制                            | server模式新生代默认垃圾回收器<br />和CMS配合                |                                                              |
| Parallel Old       | 老年代        | 并行      | 标记-整理                       | jdk1.6和Parallel Scanvenge搭配                               |                                                              |
| Parallel Scanvenge | 新生代        | 并行      | 标记-整理                       |                                                              | 吞吐量作为目标                                               |
| CMS                | 老年代        | 并行      | 标记-清除                       |                                                              |                                                              |
| G1                 | 新生代+老年代 | 并行      | 整体：标记-整理<br />局部：复制 |                                                              |                                                              |

### 5.1 CMS

### 5.2 G1



