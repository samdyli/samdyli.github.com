---
layout: post
title: 深入理解java垃圾回收
---



# {{page.title}}

------

## 一、GC概述

Java与C++在内存管理上最大的一个区别：C++需要在程序中实现内存分配和回收过程，稍有不慎就会产生内存泄露问题，Java虚拟机通过垃圾回收机制管理内存回收。



垃圾回收算法关注解决如下问题：

（1） 对象已死怎么判定： 哪些对象可以被判断为垃圾，需要被回收？

（2） 垃圾回收算法：使用什么方法回收不用内存？

（3）具体垃圾收集器及其应用： HotSpot支持哪些垃圾回收器，这些垃圾回收器使用的场景。

具体介绍垃圾回收算法之前，先介绍下JVM的内存模型。

## 二、JVM内存模型

![内存模型](img/内存模型.png)


上图是jvm的内存模型。从两个维度看jvm内存模型：（1） 各个区域存放什么东西？ （2）区域是否线程私有？

| 区域                          | 存放东西                                                     | 线程私有 | 可能异常           |
| ----------------------------- | ------------------------------------------------------------ | -------- | ------------------ |
| 执行计数器                    | 存放当前线程正在执行字节码的行号                             | 是       | 唯一无异常的区域   |
| 堆                            | 垃圾回收器管理的主要内存区域，存放运行中的对象               | 否       | OOM                |
| 虚拟机栈                      | 有方法执行过程，都会建立一个栈帧。栈帧存放局部变量表、操作数栈，动态链接和方法出口信息。局部变量表存放入参（基本类型和引用类型），编译期间分配完成。 | 是       | StackOverFlow和OOM |
| 本地方法栈                    | 同虚拟机栈，区别是执行的是本地方法（）                       | 是       | StackOverFlow和OOM |
| 方法区（非堆内存， “永久代”） | 已经加载的类的信息、常量（final修饰）、静态变量（static）、即时编译后的代码。 | 否       | OOM                |



说明几点问题：

（1） 方法区不完全等同于永久代。 永久代只是具体JVM实现，将堆得垃圾回收机制运用到方法区。有的JVM并不会对方法区进行垃圾回收，所以也不会有永久代的概念。

（2）运行期间常量池是否存放在方法区中，跟Jdk版本有关。Jdk1.6及之前，常量池存放在方法区中，方法区会因为常量池导致OOM。Jdk1.7和之后版本，常量池从方法区移到了Java堆中。

（3） 直接内存（Direct Memory）又称为堆外内存，它不会被JVM垃圾回收器回收，也不需要在工作内存（Java堆）和本地内存之间赋值，因此性能比较高。

## 三、对象已死

## 四、回收算法

## 五、 HotSpot垃圾回收器



