---
layout: post
title: 并发更新问题探究
---

## 什么是并发更新？为什么没有并发删除和并发插入问题？
并发更新从字面理解就是多个线程同时(仍然有先后顺序)更新同一个域。这样会有什么问题呢？ 
更新分为两种情况，一种是无条件的更新，另外一种是有条件的更新。

（1） 无条件更新就是指不论目前什么状况，我都会把数据更新为最新的数据。这种情况主要会出现**后发先至**。我把姓名改成张三，紧接着后悔了，又将姓名改成了王五。然而将姓名修改成张三的请求网络请求卡住了， 修改成王五的请求先到了。最后造成名字被修改成了张三，而用户预期是修改成王五。
（2） 有条件的更新指数据的更新依赖数据的现状，最典型的就是库存扣减。 要扣减库存之前，我需要先知道目前的库存是多少，然后进行扣减更新。有条件更新遇到最大的问题就是并发更新的问题。

并发更新问题本质上是读后写问题。那么，新增和删除是否也会有并发问题？为什么很少听说并发插入和并发删除的问题呢？

新增和删除也肯定会有并发问题。最典型的是想执行```Insert If Not Exist```或者```Insert or Update```的逻辑。 之所以很少是因为插入造成的并发问题很多描述为重复插入的问题，如知乎上的文章。[mysql高并发场景下重复插入如何保证唯一性](https://www.zhihu.com/question/3995226)

Insert If Not Exist问题多采用唯一约束或者唯一索引解决(性能没什么差别，唯一约束也会自动构建唯一索引), 另外Insert ...Select和Insert Or Update问题，mysql的insert语句都有原生的支持 ，可以参见[Mysql 8.0 Reference ](https://dev.mysql.com/doc/refman/8.0/en/insert.html)。

## 解决并发更新的思路

并发更新的问题发生的两个条件：

（1） 并发：单线程的处理数据库，就不会出现并发更新的问题。

（2）写之前的数据变化：会有很多因素造成这种问题。首先就是数据库的隔离级别。mysql支持未提交读(脏读问题)，提交读(RC 不可重复读)，可重复读(RR 幻读)，可串行化四种隔离级别。在mysql默认的隔离级别为RR，解决了不可重复读的问题。但是会出现写入之前数据变化的问题。还有一种情况是读-写分离造成主从延迟。

要解决并发更新，可以打破问题发生的两个条件。因此解决方案可以有：

### 打破并发条件

#### 加锁

#### 队列

### 打破写之前的不可重复读

#### 隔离界别调整至RR

#### 

## 其他思考



参考:

1. [高并发环境下某宝余额扣减方案](https://www.zhihu.com/question/61484424)：补偿型事务+冻结表，确保通知型事务。

2. [更新丢失](https://blog.csdn.net/u014590757/article/details/79612858)

3. [事务并发的可能问题与其解决方案](https://www.jianshu.com/p/71a79d838443)

   

